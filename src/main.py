#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import subprocess
import sys
import uuid
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import List

from src.common.paths import repo_root


def now_utc_iso() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


# -----------------------------
# STIX test bundle generator
# -----------------------------
def stix_id(stix_type: str) -> str:
    return f"{stix_type}--{uuid.uuid4()}"


def make_test_report_bundle(
    *,
    out_path: Path,
    report_name: str,
    publisher_name: str,
    authors: List[str],
    article_url: str,
    clean_text: str,
) -> Path:
    created = now_utc_iso()

    publisher_id = stix_id("identity")
    publisher = {
        "type": "identity",
        "spec_version": "2.1",
        "id": publisher_id,
        "created": created,
        "modified": created,
        "name": publisher_name[:256],
        "identity_class": "organization",
    }

    report_id = stix_id("report")
    report = {
        "type": "report",
        "spec_version": "2.1",
        "id": report_id,
        "created": created,
        "modified": created,
        "created_by_ref": publisher_id,  # Report author = publisher
        "name": report_name[:256],
        "description": "TEST REPORT (generated by src/main.py).",
        "published": created,
        "report_types": ["threat-report"],
        "external_references": [{"source_name": "source", "url": article_url}] if article_url else [],
        "object_refs": [],
        "x_opencti_content": clean_text,
    }

    author_line = "author: " + ("; ".join([a for a in authors if a.strip()]) if authors else "Unknown")
    publisher_line = f"publisher: {publisher_name or 'Unknown'}"
    note_content = "\n".join([author_line, publisher_line, "raw_text_ref: (not available)"]).strip()

    note = {
        "type": "note",
        "spec_version": "2.1",
        "id": stix_id("note"),
        "created": created,
        "modified": created,
        "created_by_ref": publisher_id,
        "content": note_content,
        "object_refs": [report_id],
    }

    report["object_refs"].append(note["id"])

    bundle = {
        "type": "bundle",
        "id": f"bundle--{uuid.uuid4()}",
        "spec_version": "2.1",
        "objects": [publisher, report, note],
    }

    ensure_dir(out_path.parent)
    out_path.write_text(json.dumps(bundle, ensure_ascii=False, indent=2), encoding="utf-8")
    return out_path


# -----------------------------
# Stage4 runner
# -----------------------------
@dataclass
class Step:
    num: int
    name: str
    module: str  # ★ ファイルパスではなくモジュール名で管理する


def run_cmd(cmd: List[str], *, cwd: Path, dry_run: bool) -> None:
    print(">", " ".join(cmd))
    if dry_run:
        return
    subprocess.run(cmd, cwd=str(cwd), check=True)


def main() -> None:
    root = repo_root()

    # ★ 01〜04は常に「python -m src.stage4....」で呼ぶ
    steps = [
        Step(1, "extract_included", "src.stage4.01_extract_included"),
        Step(2, "fetch_and_clean", "src.stage4.02_fetch_and_clean_article"),
        Step(3, "extract_stix", "src.stage4.03_extract_stix_entities"),
        Step(4, "build_bundle", "src.stage4.04_build_stix_bundle"),
    ]

    parser = argparse.ArgumentParser(description="Crawl_Server orchestrator (Xubuntu/Linux).")
    parser.add_argument("--dry-run", action="store_true", help="Print commands only; do not execute.")
    parser.add_argument("--python", default=sys.executable, help="Python executable (default: current).")

    # Stage4 pipeline
    parser.add_argument("--stage4", action="store_true", help="Run Stage4 pipeline (01->04).")
    parser.add_argument("--from-step", type=int, default=1, choices=[1, 2, 3, 4], help="Start step number.")
    parser.add_argument("--to-step", type=int, default=4, choices=[1, 2, 3, 4], help="End step number.")

    # Common paths (defaults)
    parser.add_argument("--data-dir", default=str(root / "data"), help="Data directory (default: <root>/data).")
    parser.add_argument("--prompts-dir", default=str(root / "prompts"), help="Prompts directory (default: <root>/prompts).")

    # Test bundle generator
    parser.add_argument("--make-test-report", action="store_true", help="Generate a test STIX bundle with a Report.")
    parser.add_argument("--test-out", default=str(root / "data" / "test_report_bundle.json"), help="Test bundle output path.")
    parser.add_argument("--test-report-name", default="Test Report - Author in Note", help="Report name.")
    parser.add_argument("--test-publisher", default="BleepingComputer", help="Publisher (Organization) name.")
    parser.add_argument("--test-authors", default="John Doe; Jane Roe", help="Authors (semicolon-separated).")
    parser.add_argument("--test-url", default="https://example.com/test-article", help="Article URL for external reference.")
    parser.add_argument("--test-clean", default="This is a test clean_text for OpenCTI Report.content.", help="clean_text content.")

    args = parser.parse_args()

    # 1) Test bundle generation
    if args.make_test_report:
        authors = [a.strip() for a in args.test_authors.split(";") if a.strip()]
        out = make_test_report_bundle(
            out_path=Path(args.test_out).expanduser().resolve(),
            report_name=args.test_report_name,
            publisher_name=args.test_publisher,
            authors=authors,
            article_url=args.test_url,
            clean_text=args.test_clean,
        )
        print(f"✅ wrote test bundle: {out}")
        if not args.stage4:
            return

    # 2) Stage4 pipeline
    if args.stage4:
        start = args.from_step
        end = args.to_step
        if start > end:
            raise SystemExit("--from-step must be <= --to-step")

        for st in steps:
            if not (start <= st.num <= end):
                continue

            # ★ ここが根本修正：ファイルパスではなく -m でモジュール実行
            cmd = [args.python, "-m", st.module]

            run_cmd(cmd, cwd=root, dry_run=args.dry_run)

        print("✅ Stage4 pipeline finished.")
        return

    print("No action specified. Use --stage4 and/or --make-test-report.")
    print("Examples:")
    print("  python -m src.main --make-test-report")
    print("  python -m src.main --stage4")
    print("  python -m src.main --stage4 --from-step 2 --to-step 4")


if __name__ == "__main__":
    main()
