#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import subprocess
import sys
import uuid
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional


# -----------------------------
# Path helpers
# -----------------------------
def repo_root() -> Path:
    # src/main.py -> repo root is parent of src
    return Path(__file__).resolve().parents[1]


def now_utc_iso() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


# -----------------------------
# STIX test bundle generator
# -----------------------------
def stix_id(stix_type: str) -> str:
    return f"{stix_type}--{uuid.uuid4()}"


def make_test_report_bundle(
    *,
    out_path: Path,
    report_name: str,
    publisher_name: str,
    authors: List[str],
    article_url: str,
    clean_text: str,
) -> Path:
    """
    OpenCTIにインポート可能な最小のSTIX2.1 bundle:
    - publisher: identity (organization)
    - report: created_by_ref = publisher
    - note: Overviewに author: ... を表示する想定
    - (optional) x_opencti_content に clean_text を入れる（OpenCTI拡張を想定）
    """
    created = now_utc_iso()

    publisher_id = stix_id("identity")
    publisher = {
        "type": "identity",
        "spec_version": "2.1",
        "id": publisher_id,
        "created": created,
        "modified": created,
        "name": publisher_name[:256],
        "identity_class": "organization",
    }

    report_id = stix_id("report")
    report = {
        "type": "report",
        "spec_version": "2.1",
        "id": report_id,
        "created": created,
        "modified": created,
        "created_by_ref": publisher_id,  # Report author = publisher
        "name": report_name[:256],
        "description": "TEST REPORT (generated by src/main.py).",
        "published": created,
        "report_types": ["threat-report"],
        "external_references": [{"source_name": "source", "url": article_url}] if article_url else [],
        "object_refs": [],
        # OpenCTI向け: clean_text をReport側に保持したい場合（あなたの方針）
        "x_opencti_content": clean_text,
    }

    # Note: Overview Notesの先頭行に author: ... を出す
    author_line = "author: " + ("; ".join([a for a in authors if a.strip()]) if authors else "Unknown")
    publisher_line = f"publisher: {publisher_name or 'Unknown'}"
    note_content = "\n".join([author_line, publisher_line, "raw_text_ref: (not available)"]).strip()

    note = {
        "type": "note",
        "spec_version": "2.1",
        "id": stix_id("note"),
        "created": created,
        "modified": created,
        "created_by_ref": publisher_id,
        "content": note_content,
        "object_refs": [report_id],
    }

    # ReportがNoteも辿れるように参照（OpenCTIで見通しが良い）
    report["object_refs"].append(note["id"])

    bundle = {
        "type": "bundle",
        "id": f"bundle--{uuid.uuid4()}",
        "spec_version": "2.1",
        "objects": [publisher, report, note],
    }

    ensure_dir(out_path.parent)
    out_path.write_text(json.dumps(bundle, ensure_ascii=False, indent=2), encoding="utf-8")
    return out_path


# -----------------------------
# Stage4 runner
# -----------------------------
@dataclass
class Step:
    num: int
    name: str
    rel_script: Path


def run_cmd(cmd: List[str], *, cwd: Path, dry_run: bool) -> None:
    print(">", " ".join(cmd))
    if dry_run:
        return
    subprocess.run(cmd, cwd=str(cwd), check=True)


def main() -> None:
    root = repo_root()

    steps = [
        Step(1, "extract_included", root / "src" / "stage4" / "01_extract_included.py"),
        Step(2, "fetch_and_clean", root / "src" / "stage4" / "02_fetch_and_clean_article.py"),
        Step(3, "extract_stix", root / "src" / "stage4" / "03_extract_stix_entities.py"),
        Step(4, "build_bundle", root / "src" / "stage4" / "04_build_stix_bundle.py"),
    ]

    parser = argparse.ArgumentParser(description="Crawl_Server orchestrator (Xubuntu/Linux).")
    parser.add_argument("--dry-run", action="store_true", help="Print commands only; do not execute.")
    parser.add_argument("--python", default=sys.executable, help="Python executable (default: current).")

    # Stage4 pipeline
    parser.add_argument("--stage4", action="store_true", help="Run Stage4 pipeline (01->04).")
    parser.add_argument("--from-step", type=int, default=1, choices=[1, 2, 3, 4], help="Start step number.")
    parser.add_argument("--to-step", type=int, default=4, choices=[1, 2, 3, 4], help="End step number.")

    # Common paths (defaults are your current convention)
    parser.add_argument("--data-dir", default=str(root / "data"), help="Data directory (default: <root>/data).")
    parser.add_argument("--prompts-dir", default=str(root / "prompts"), help="Prompts directory (default: <root>/prompts).")

    # Test bundle generator
    parser.add_argument("--make-test-report", action="store_true", help="Generate a test STIX bundle with a Report.")
    parser.add_argument("--test-out", default=str(root / "data" / "test_report_bundle.json"), help="Test bundle output path.")
    parser.add_argument("--test-report-name", default="Test Report - Author in Note", help="Report name.")
    parser.add_argument("--test-publisher", default="BleepingComputer", help="Publisher (Organization) name.")
    parser.add_argument("--test-authors", default="John Doe; Jane Roe", help="Authors (semicolon-separated).")
    parser.add_argument("--test-url", default="https://example.com/test-article", help="Article URL for external reference.")
    parser.add_argument("--test-clean", default="This is a test clean_text for OpenCTI Report.content.", help="clean_text content.")

    args = parser.parse_args()

    data_dir = Path(args.data_dir)
    prompts_dir = Path(args.prompts_dir)

    # 1) Test bundle generation
    if args.make_test_report:
        authors = [a.strip() for a in args.test_authors.split(";") if a.strip()]
        out = make_test_report_bundle(
            out_path=Path(args.test_out),
            report_name=args.test_report_name,
            publisher_name=args.test_publisher,
            authors=authors,
            article_url=args.test_url,
            clean_text=args.test_clean,
        )
        print(f"✅ wrote test bundle: {out}")
        # make-testだけで終わる運用もあるので、stage4指定が無ければ終了
        if not args.stage4:
            return

    # 2) Stage4 pipeline
    if args.stage4:
        start = args.from_step
        end = args.to_step
        if start > end:
            raise SystemExit("--from-step must be <= --to-step")

        # Quick existence check
        for st in steps:
            if start <= st.num <= end and not st.rel_script.exists():
                raise SystemExit(f"Missing script: {st.rel_script}")

        # Build commands.
        # それぞれのスクリプトはデフォルトパスで動く前提（あなたの構成に合わせる）
        for st in steps:
            if not (start <= st.num <= end):
                continue

            cmd = [args.python, str(st.rel_script)]

            # 必要なら個別引数をここで追加可能（例: promptパス、limit等）
            # Stage4A/4B promptがデフォルト以外の場合に備えて、prompts-dirを使う例:
            if st.num == 2:
                # 02_fetch_and_clean.py: prompt default <root>/prompts/stage4a_clean.md
                # 変更したいならここで上書き可能:
                # cmd += ["--prompt", str(prompts_dir / "stage4a_clean.md")]
                pass
            if st.num == 3:
                # 03_extract_stix_entities.py: prompt default <root>/prompts/stage4b_extract.md
                # cmd += ["--prompt", str(prompts_dir / "stage4b_extract.md")]
                pass

            run_cmd(cmd, cwd=root, dry_run=args.dry_run)

        print("✅ Stage4 pipeline finished.")
        return

    # If nothing selected
    print("No action specified. Use --stage4 and/or --make-test-report.")
    print("Examples:")
    print("  python -m src.main --make-test-report")
    print("  python -m src.main --stage4")
    print("  python -m src.main --stage4 --from-step 2 --to-step 4")


if __name__ == "__main__":
    main()
